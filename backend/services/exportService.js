const puppeteer = require('puppeteer');
const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = require('docx');
const { jsPDF } = require('jspdf');
const fs = require('fs');
const path = require('path');

class ExportService {
  constructor() {
    this.ensureExportDirs();
  }

  ensureExportDirs() {
    const dirs = ['./exports/pdf', './exports/word'];
    dirs.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  // Generate PDF from RTI text
  async generatePDF(rtiText, options = {}) {
    try {
      const {
        fileName = 'rti-application',
        includeHeader = true,
        includeFooter = true,
        fontSize = '14px',
        fontFamily = 'Arial, sans-serif'
      } = options;

      // Create HTML content
      const htmlContent = this.createHTMLContent(rtiText, {
        includeHeader,
        includeFooter,
        fontSize,
        fontFamily
      });

      // Launch Puppeteer
      const browser = await puppeteer.launch({
        headless: 'new',
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });

      const page = await browser.newPage();
      
      // Set content
      await page.setContent(htmlContent, { waitUntil: 'networkidle0' });

      // Generate PDF
      const pdfBuffer = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '20mm',
          right: '20mm',
          bottom: '20mm',
          left: '20mm'
        },
        displayHeaderFooter: true,
        headerTemplate: includeHeader ? this.getHeaderTemplate() : '',
        footerTemplate: includeFooter ? this.getFooterTemplate() : ''
      });

      await browser.close();

      // Save file
      const fileNameWithExt = `${fileName}-${Date.now()}.pdf`;
      const filePath = path.join('./exports/pdf', fileNameWithExt);
      fs.writeFileSync(filePath, pdfBuffer);

      return {
        success: true,
        fileName: fileNameWithExt,
        filePath,
        fileSize: pdfBuffer.length,
        mimeType: 'application/pdf'
      };
    } catch (error) {
      console.error('Error generating PDF:', error);
      throw new Error(`Failed to generate PDF: ${error.message}`);
    }
  }

  // Generate Word document from RTI text
  async generateWord(rtiText, options = {}) {
    try {
      const {
        fileName = 'rti-application',
        includeHeader = true
      } = options;

      // Parse RTI text into sections
      const sections = this.parseRTIText(rtiText);

      // Create Word document
      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            // Header
            ...(includeHeader ? [this.createHeaderParagraph()] : []),
            
            // Main content
            ...sections.map(section => this.createSectionParagraph(section)),
            
            // Footer
            ...(includeHeader ? [this.createFooterParagraph()] : [])
          ]
        }]
      });

      // Generate buffer
      const buffer = await Packer.toBuffer(doc);

      // Save file
      const fileNameWithExt = `${fileName}-${Date.now()}.docx`;
      const filePath = path.join('./exports/word', fileNameWithExt);
      fs.writeFileSync(filePath, buffer);

      return {
        success: true,
        fileName: fileNameWithExt,
        filePath,
        fileSize: buffer.length,
        mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      };
    } catch (error) {
      console.error('Error generating Word document:', error);
      throw new Error(`Failed to generate Word document: ${error.message}`);
    }
  }

  // Create HTML content for PDF
  createHTMLContent(rtiText, options) {
    const { includeHeader, includeFooter, fontSize, fontFamily } = options;
    
    const header = includeHeader ? `
      <div class="header">
        <h1>RTI Application</h1>
        <p>Generated on ${new Date().toLocaleDateString('en-IN')}</p>
      </div>
    ` : '';

    const footer = includeFooter ? `
      <div class="footer">
        <p>Generated by RTI Assistant - www.rtiassistant.in</p>
      </div>
    ` : '';

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body {
            font-family: ${fontFamily};
            font-size: ${fontSize};
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 20px;
          }
          .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #2563eb;
            padding-bottom: 20px;
          }
          .header h1 {
            color: #2563eb;
            margin: 0;
            font-size: 24px;
          }
          .header p {
            color: #666;
            margin: 5px 0 0 0;
            font-size: 12px;
          }
          .content {
            white-space: pre-line;
            text-align: justify;
          }
          .footer {
            margin-top: 30px;
            text-align: center;
            border-top: 1px solid #ddd;
            padding-top: 20px;
            font-size: 12px;
            color: #666;
          }
          @media print {
            body { margin: 0; }
            .header, .footer { page-break-inside: avoid; }
          }
        </style>
      </head>
      <body>
        ${header}
        <div class="content">${rtiText}</div>
        ${footer}
      </body>
      </html>
    `;
  }

  // Get header template for PDF
  getHeaderTemplate() {
    return `
      <div style="font-size: 10px; text-align: center; width: 100%; color: #666;">
        <span>RTI Application - Generated by RTI Assistant</span>
      </div>
    `;
  }

  // Get footer template for PDF
  getFooterTemplate() {
    return `
      <div style="font-size: 10px; text-align: center; width: 100%; color: #666;">
        <span>Page <span class="pageNumber"></span> of <span class="totalPages"></span></span>
      </div>
    `;
  }

  // Parse RTI text into sections for Word document
  parseRTIText(rtiText) {
    const lines = rtiText.split('\n').filter(line => line.trim());
    const sections = [];
    let currentSection = { type: 'paragraph', content: '' };

    for (const line of lines) {
      const trimmedLine = line.trim();
      
      if (this.isHeading(trimmedLine)) {
        if (currentSection.content) {
          sections.push(currentSection);
        }
        currentSection = {
          type: 'heading',
          content: trimmedLine
        };
      } else if (this.isSignature(trimmedLine)) {
        if (currentSection.content) {
          sections.push(currentSection);
        }
        currentSection = {
          type: 'signature',
          content: trimmedLine
        };
      } else {
        if (currentSection.type === 'paragraph') {
          currentSection.content += (currentSection.content ? '\n' : '') + line;
        } else {
          sections.push(currentSection);
          currentSection = {
            type: 'paragraph',
            content: line
          };
        }
      }
    }

    if (currentSection.content) {
      sections.push(currentSection);
    }

    return sections;
  }

  // Check if line is a heading
  isHeading(line) {
    const headingPatterns = [
      /^To\s*,/i,
      /^Subject\s*:/i,
      /^Sir\/Madam\s*,/i,
      /^Thanking\s+you\s*,/i,
      /^Yours\s+faithfully\s*,/i
    ];
    
    return headingPatterns.some(pattern => pattern.test(line));
  }

  // Check if line is signature section
  isSignature(line) {
    const signaturePatterns = [
      /^Date\s*:/i,
      /^Place\s*:/i,
      /^Address\s*:/i,
      /^Phone\s*:/i,
      /^Email\s*:/i
    ];
    
    return signaturePatterns.some(pattern => pattern.test(line));
  }

  // Create header paragraph for Word
  createHeaderParagraph() {
    return new Paragraph({
      children: [
        new TextRun({
          text: "RTI Application",
          bold: true,
          size: 32,
          color: "2563eb"
        })
      ],
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    });
  }

  // Create section paragraph for Word
  createSectionParagraph(section) {
    const textRuns = section.content.split('\n').map(line => 
      new TextRun({
        text: line,
        size: section.type === 'heading' ? 24 : 20,
        bold: section.type === 'heading',
        color: section.type === 'heading' ? "2563eb" : "333333"
      })
    );

    return new Paragraph({
      children: textRuns,
      alignment: section.type === 'signature' ? AlignmentType.RIGHT : AlignmentType.LEFT,
      spacing: { 
        after: section.type === 'heading' ? 200 : 100,
        before: section.type === 'heading' ? 200 : 0
      }
    });
  }

  // Create footer paragraph for Word
  createFooterParagraph() {
    return new Paragraph({
      children: [
        new TextRun({
          text: `Generated by RTI Assistant on ${new Date().toLocaleDateString('en-IN')}`,
          size: 16,
          color: "666666",
          italics: true
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: { before: 400 }
    });
  }

  // Delete export file
  deleteExportFile(filePath) {
    try {
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error deleting export file:', error);
      return false;
    }
  }

  // Get file info
  getFileInfo(filePath) {
    try {
      if (!fs.existsSync(filePath)) {
        return null;
      }

      const stats = fs.statSync(filePath);
      const ext = path.extname(filePath).toLowerCase();
      
      const mimeTypes = {
        '.pdf': 'application/pdf',
        '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      };

      return {
        fileName: path.basename(filePath),
        filePath,
        fileSize: stats.size,
        mimeType: mimeTypes[ext] || 'application/octet-stream',
        createdAt: stats.birthtime,
        modifiedAt: stats.mtime
      };
    } catch (error) {
      console.error('Error getting file info:', error);
      return null;
    }
  }

  // Clean up old export files (older than 24 hours)
  cleanupOldFiles() {
    try {
      const dirs = ['./exports/pdf', './exports/word'];
      const cutoffTime = Date.now() - (24 * 60 * 60 * 1000); // 24 hours ago
      
      dirs.forEach(dir => {
        if (fs.existsSync(dir)) {
          const files = fs.readdirSync(dir);
          
          files.forEach(file => {
            const filePath = path.join(dir, file);
            const stats = fs.statSync(filePath);
            
            if (stats.mtime.getTime() < cutoffTime) {
              fs.unlinkSync(filePath);
              console.log(`Cleaned up old export file: ${filePath}`);
            }
          });
        }
      });
    } catch (error) {
      console.error('Error cleaning up old files:', error);
    }
  }
}

module.exports = new ExportService();
